<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>HTML SOULS - Mini Edition</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚔️</text></svg>">
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: 'Cinzel', serif;
}

#ui {
  position: absolute;
  top: 30px;
  left: 30px;
  color: #c4a96c;
  font-family: 'Cinzel', serif;
  font-size: 24px;
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
  display: none;
  letter-spacing: 2px;
  line-height: 1.8;
  z-index: 10;
}

#ui span {
  color: #f0d8a8;
  font-weight: bold;
  margin-left: 10px;
}

#souls {
  position: absolute;
  top: 30px;
  right: 30px;
  color: #c4a96c;
  font-family: 'Cinzel', serif;
  font-size: 28px;
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
  display: none;
  letter-spacing: 3px;
  z-index: 10;
}

#souls span {
  color: #f0d8a8;
  font-weight: bold;
  margin-left: 10px;
}

#bonfireHint {
  position: absolute;
  bottom: 100px;
  left: 50%;
  transform: translateX(-50%);
  color: #c4a96c;
  font-family: 'Cinzel', serif;
  font-size: 20px;
  background: rgba(0, 0, 0, 0.8);
  padding: 12px 24px;
  border: 1px solid #7a653a;
  display: none;
  letter-spacing: 2px;
  animation: pulse 2s infinite;
  z-index: 10;
}

@keyframes pulse {
  0% { opacity: 0.7; border-color: #7a653a; }
  50% { opacity: 1; border-color: #c4a96c; }
  100% { opacity: 0.7; border-color: #7a653a; }
}

#cameraHint {
  position: absolute;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  color: #aaa;
  font-family: 'Cinzel', serif;
  font-size: 14px;
  background: rgba(0, 0, 0, 0.6);
  padding: 8px 20px;
  border-radius: 20px;
  pointer-events: none;
  display: none;
  letter-spacing: 1px;
  border: 1px solid #333;
  z-index: 10;
}

.roll-indicator {
  position: absolute;
  bottom: 180px;
  left: 50%;
  transform: translateX(-50%);
  color: #fff;
  font-family: 'Cinzel', serif;
  background: rgba(0, 0, 0, 0.8);
  padding: 10px 25px;
  border-radius: 5px;
  border: 1px solid #c4a96c;
  display: none;
  font-size: 18px;
  letter-spacing: 2px;
  z-index: 10;
}

#menuOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #0a0a0a;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  font-family: 'Cinzel', serif;
}

.menu-container {
  text-align: center;
  padding: 50px;
  background: transparent;
  position: relative;
  min-width: 550px;
  border: 1px solid #3a3a3a;
}

.menu-container h1 {
  color: #d4b47c;
  font-size: 72px;
  margin-bottom: 10px;
  letter-spacing: 8px;
  font-weight: 400;
  text-shadow: 0 0 10px rgba(180, 140, 80, 0.3);
}

.menu-container h2 {
  color: #a88e5a;
  font-size: 16px;
  margin-bottom: 50px;
  letter-spacing: 6px;
  text-transform: uppercase;
  font-weight: 300;
}

.menu-button {
  background: transparent;
  color: #b89e6a;
  border: 1px solid #5a4a2a;
  padding: 15px 40px;
  margin: 10px 0;
  font-size: 24px;
  font-family: 'Cinzel', serif;
  cursor: pointer;
  transition: all 0.2s ease;
  width: 380px;
  text-transform: uppercase;
  letter-spacing: 4px;
  position: relative;
}

.menu-button:hover {
  color: #f0d0a0;
  border-color: #b89e6a;
  background: rgba(180, 140, 80, 0.1);
}

.menu-button.secondary {
  border-color: #3a3a3a;
  color: #8a7a5a;
  font-size: 20px;
}

.menu-button.secondary:hover {
  border-color: #6a5a3a;
  color: #b89e6a;
}

.stats-preview {
  color: #7a6a4a;
  margin-top: 60px;
  padding-top: 20px;
  border-top: 1px solid #3a3a3a;
  font-size: 14px;
  line-height: 2.2;
  letter-spacing: 2px;
}

.stats-preview div {
  margin: 5px 0;
}

.stats-preview span {
  color: #c4a96c;
  font-weight: bold;
}

#startHint {
  color: #5a4a2a;
  margin-top: 40px;
  font-size: 14px;
  letter-spacing: 3px;
  animation: hintPulse 2s infinite;
}

@keyframes hintPulse {
  0% { opacity: 0.5; }
  50% { opacity: 1; }
  100% { opacity: 0.5; }
}

#pauseOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 900;
  font-family: 'Cinzel', serif;
}

.pause-container {
  text-align: center;
  padding: 50px;
  background: transparent;
  position: relative;
  min-width: 450px;
  border: 1px solid #5a4a2a;
}

.pause-container h2 {
  color: #b89e6a;
  font-size: 48px;
  margin-bottom: 40px;
  letter-spacing: 6px;
  font-weight: 400;
}

#loadingOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #0a0a0a;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1200;
  color: #b89e6a;
  font-size: 24px;
  font-family: 'Cinzel', serif;
  flex-direction: column;
}

#loadingMessage {
  margin-bottom: 20px;
  letter-spacing: 4px;
  animation: loadingPulse 1.5s infinite;
}

@keyframes loadingPulse {
  0% { opacity: 0.5; }
  50% { opacity: 1; }
  100% { opacity: 0.5; }
}

#loadingError {
  color: #b66a6a;
  font-size: 16px;
  margin-top: 20px;
  display: none;
  max-width: 500px;
  text-align: center;
  padding: 20px;
  border: 1px solid #6a3a3a;
  letter-spacing: 2px;
}

.retry-button {
  background: transparent;
  color: #b89e6a;
  border: 1px solid #5a4a2a;
  padding: 10px 30px;
  margin-top: 20px;
  font-size: 18px;
  font-family: 'Cinzel', serif;
  cursor: pointer;
  transition: all 0.2s ease;
  letter-spacing: 2px;
}

.retry-button:hover {
  background: rgba(180, 140, 80, 0.2);
  border-color: #b89e6a;
}
</style>
</head>
<body>

<div id="menuOverlay">
  <div class="menu-container">
    <h1>HTML SOULS</h1>
    <h2>MINI EDITION</h2>

    <button class="menu-button" id="continueBtn">CONTINUE</button>
    <button class="menu-button" id="newGameBtn">NEW GAME</button>
    <button class="menu-button secondary" id="settingsBtn">SETTINGS</button>

    <div class="stats-preview">
      <div>SOULS <span id="menuSouls">0</span></div>
      <div>BONFIRES <span id="menuBonfires">1</span></div>
      <div>ENEMIES <span id="menuEnemies">0</span></div>
      <div>TIME <span id="menuTime">00:00</span></div>
    </div>

    <div id="startHint">PRESS SPACE TO BEGIN</div>
  </div>
</div>

<div id="pauseOverlay">
  <div class="pause-container">
    <h2>PAUSED</h2>
    <button class="menu-button" id="resumeBtn">CONTINUE</button>
    <button class="menu-button" id="restartBtn">RESTART</button>
    <button class="menu-button secondary" id="menuBtn">MENU</button>
  </div>
</div>

<div id="loadingOverlay">
  <div id="loadingMessage">LOADING...</div>
  <div id="loadingError"></div>
  <button class="retry-button" id="retryBtn" style="display:none;">RETRY</button>
  <button class="retry-button" id="useFallbackBtn" style="display:none;">FALLBACK</button>
</div>

<div id="ui">
HEALTH <span id="hp">5</span>/5<br>
STAMINA <span id="st">100</span>/100
</div>
<div id="souls">
SOULS <span id="soulCount">0</span>
</div>
<div id="bonfireHint">PRESS E TO REST AT BONFIRE</div>
<div id="cameraHint">MOUSE = CAMERA | SHIFT = ROLL (3s COOLDOWN)</div>
<div class="roll-indicator" id="rollIndicator">ROLLING</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
// ===== FUNÇÃO PARA DETECTAR CAMINHO BASE NO GITHUB PAGES =====
function getBasePath() {
  // Detecta se está no GitHub Pages
  if (window.location.hostname.includes('github.io')) {
    // Pega o caminho até o repositório
    const pathParts = window.location.pathname.split('/');
    // Remove o último elemento se for um arquivo
    if (pathParts[pathParts.length - 1].includes('.')) {
      pathParts.pop();
    }
    const repoPath = pathParts.join('/');
    console.log('GitHub Pages detectado, repo path:', repoPath);
    return repoPath.endsWith('/') ? repoPath : repoPath + '/';
  }
  // Localhost ou arquivo local
  console.log('Ambiente local detectado');
  return './';
}

// ===== VARIÁVEIS GLOBAIS =====
const menuOverlay = document.getElementById('menuOverlay');
const pauseOverlay = document.getElementById('pauseOverlay');
const loadingOverlay = document.getElementById('loadingOverlay');
const loadingMessage = document.getElementById('loadingMessage');
const loadingError = document.getElementById('loadingError');
const retryBtn = document.getElementById('retryBtn');
const useFallbackBtn = document.getElementById('useFallbackBtn');
const ui = document.getElementById('ui');
const souls = document.getElementById('souls');
const bonfireHint = document.getElementById('bonfireHint');
const cameraHint = document.getElementById('cameraHint');

const menuSouls = document.getElementById('menuSouls');
const menuBonfires = document.getElementById('menuBonfires');
const menuEnemies = document.getElementById('menuEnemies');
const menuTime = document.getElementById('menuTime');

let gameStarted = false;
let gamePaused = false;
let player = null;
let playerGroup = new THREE.Group();
let clock = new THREE.Clock();
let skeletonMixers = [];
let bonfireModel = null;
let playTime = 0;
let enemiesSlain = 0;

let cameraAngle = 0;
let targetCameraAngle = 0;
let mouseX = 0;
let mouseY = 0;
let cameraVerticalAngle = 0.2;
const MAX_VERTICAL_ANGLE = 0.5;
const MIN_VERTICAL_ANGLE = -0.2;
const cameraDistance = 5;
const cameraHeight = 2.5;
const cameraSmoothness = 0.1;

// ===== MAP LIMIT =====
const MAP_LIMIT = 25;

// ===== SAVE SYSTEM =====
let savedGame = {
  souls: 0,
  enemiesSlain: 0,
  playTime: 0,
  position: { x: 2, y: 0, z: 2 }
};

let timeInterval;

// ===== EVENT LISTENERS =====
document.getElementById('continueBtn').addEventListener('click', continueGame);
document.getElementById('newGameBtn').addEventListener('click', newGame);
document.getElementById('settingsBtn').addEventListener('click', showSettings);
document.getElementById('resumeBtn').addEventListener('click', resumeGame);
document.getElementById('restartBtn').addEventListener('click', restartGame);
document.getElementById('menuBtn').addEventListener('click', backToMenu);
retryBtn.addEventListener('click', () => loadHighQualityModel());
useFallbackBtn.addEventListener('click', () => {
  loadingOverlay.style.display = 'none';
  createFallbackPlayer();
  if(!gameStarted) {
    menuOverlay.style.display = 'flex';
  }
});

document.addEventListener('mousemove', (e) => {
  if (!gameStarted || gamePaused) return;

  mouseX = (e.clientX / window.innerWidth) * 2 - 1;
  mouseY = (e.clientY / window.innerHeight) * 2 - 1;
  
  targetCameraAngle = mouseX * Math.PI;
  
  cameraVerticalAngle += -mouseY * 0.02;
  cameraVerticalAngle = Math.max(MIN_VERTICAL_ANGLE, Math.min(MAX_VERTICAL_ANGLE, cameraVerticalAngle));
});

document.addEventListener('keydown', (e) => {
  if(e.key === 'Escape') {
    if(gameStarted && !gamePaused) {
      pauseGame();
    } else if(gamePaused) {
      resumeGame();
    }
  }

  if(e.key === ' ' && !gameStarted && menuOverlay.style.display === 'flex') {
    newGame();
  }

  const key = e.key.toLowerCase();
  keys[key] = true;

  if(key === 'l' && gameStarted && !gamePaused) {
    lockOn = !lockOn;
    if(lockOn && enemies.length > 0) {
      targetEnemy = enemies.reduce((closest, enemy) => {
        if(!enemy.userData.isAlive) return closest;
        const d = playerGroup.position.distanceTo(enemy.position);
        if(!closest || d < playerGroup.position.distanceTo(closest.position)) return enemy;
        return closest;
      }, null);
    }
  }

  if(key === 'e' && gameStarted && !gamePaused && nearBonfire) restAtBonfire();
  if(key === 'shift' && gameStarted && !gamePaused && player && player.onGround && player.stamina >= 30 && !player.isRolling) performRoll();
});

document.addEventListener('keyup', (e) => {
  const key = e.key.toLowerCase();
  keys[key] = false;
});

document.addEventListener('mousedown', e => {
  if(e.button !== 0 || !gameStarted || gamePaused || !player) return;
  if(player.stamina < 20 || player.isRolling) return;

  let playerDir;
  if (playerGroup.children[0]) {
    playerDir = new THREE.Vector3(0, 0, 1).applyQuaternion(playerGroup.children[0].quaternion);
  } else {
    playerDir = new THREE.Vector3(Math.sin(cameraAngle), 0, Math.cos(cameraAngle));
  }
  playerDir.normalize();

  let closest = null;
  let closestDist = 2.5;

  enemies.forEach(enemy => {
    if(!enemy.userData.isAlive) return;
    const d = playerGroup.position.distanceTo(enemy.position);
    if(d < closestDist) {
      const enemyDir = new THREE.Vector3().subVectors(enemy.position, playerGroup.position).normalize();
      const dot = playerDir.dot(enemyDir);
      const angle = Math.acos(Math.max(-1, Math.min(1, dot))) * 180 / Math.PI;
      if (angle < 45) {
        closestDist = d;
        closest = enemy;
      }
    }
  });

  if(closest) {
    player.stamina -= 20;
    closest.userData.hp--;

    closest.traverse((child) => {
      if (child.isMesh) child.material.emissive?.setHex(0x442200);
      setTimeout(() => {
        if (child.material) child.material.emissive?.setHex(0x000000);
      }, 150);
    });

    updateHealthBar(closest);

    if(closest.userData.hp <= 0) {
      closest.userData.isAlive = false;
      enemiesSlain++;
      if (menuEnemies) menuEnemies.innerText = enemiesSlain;

      if (closest.userData.soulMesh) closest.userData.soulMesh.visible = true;
      if(closest.userData.healthBar) closest.userData.healthBar.sprite.visible = false;

      setTimeout(() => {
        const index = enemies.indexOf(closest);
        if(index > -1) {
          scene.remove(closest);
          enemies.splice(index, 1);
        }
        const basePath = getBasePath();
        const loader = new THREE.GLTFLoader();
        loadSingleSkeleton(loader, enemies.length, false, basePath + 'Enemys/Skeleton.glb');
      }, 3000);
    }
  }
});

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ===== FUNÇÕES DO MENU =====
function continueGame() {
  if(!player) {
    loadingMessage.innerHTML = 'LOADING...';
    loadingOverlay.style.display = 'flex';
    setTimeout(() => {
      loadingOverlay.style.display = 'none';
    }, 2000);
    return;
  }

  menuOverlay.style.display = 'none';
  ui.style.display = 'block';
  souls.style.display = 'block';
  cameraHint.style.display = 'block';
  gameStarted = true;

  playerGroup.position.set(savedGame.position.x, savedGame.position.y, savedGame.position.z);
  player.hp = player.maxHp || 5;
  player.stamina = player.maxStamina || 100;
  player.souls = savedGame.souls;
  enemiesSlain = savedGame.enemiesSlain;
  playTime = savedGame.playTime;

  document.getElementById('soulCount').innerText = player.souls;
  if (menuSouls) menuSouls.innerText = player.souls;
  if (menuEnemies) menuEnemies.innerText = enemiesSlain;

  if (menuTime) {
    const minutes = Math.floor(playTime / 60);
    const seconds = playTime % 60;
    menuTime.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }

  if (timeInterval) clearInterval(timeInterval);
  timeInterval = setInterval(() => {
    playTime++;
    const minutes = Math.floor(playTime / 60);
    const seconds = playTime % 60;
    if (menuTime) {
      menuTime.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    savedGame.playTime = playTime;
    savedGame.souls = player.souls;
    savedGame.enemiesSlain = enemiesSlain;
    savedGame.position = {
      x: playerGroup.position.x,
      y: playerGroup.position.y,
      z: playerGroup.position.z
    };
  }, 1000);
}

function newGame() {
  if(!player) {
    loadingMessage.innerHTML = 'LOADING...';
    loadingOverlay.style.display = 'flex';
    setTimeout(() => {
      loadingOverlay.style.display = 'none';
    }, 2000);
    return;
  }

  menuOverlay.style.display = 'none';
  ui.style.display = 'block';
  souls.style.display = 'block';
  cameraHint.style.display = 'block';
  gameStarted = true;

  playerGroup.position.set(2, 0, 2);
  player.hp = player.maxHp || 5;
  player.stamina = player.maxStamina || 100;
  player.souls = 0;
  enemiesSlain = 0;
  playTime = 0;

  document.getElementById('soulCount').innerText = '0';
  if (menuSouls) menuSouls.innerText = '0';
  if (menuEnemies) menuEnemies.innerText = '0';
  if (menuTime) menuTime.innerText = '00:00';

  enemies.forEach(enemy => scene.remove(enemy));
  enemies.length = 0;
  const basePath = getBasePath();
  const loader = new THREE.GLTFLoader();
  for (let i = 0; i < 3; i++) {
    loadSingleSkeleton(loader, i, false, basePath + 'Enemys/Skeleton.glb');
  }

  if (timeInterval) clearInterval(timeInterval);
  timeInterval = setInterval(() => {
    playTime++;
    const minutes = Math.floor(playTime / 60);
    const seconds = playTime % 60;
    if (menuTime) {
      menuTime.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    savedGame.playTime = playTime;
    savedGame.souls = player.souls;
    savedGame.enemiesSlain = enemiesSlain;
    savedGame.position = {
      x: playerGroup.position.x,
      y: playerGroup.position.y,
      z: playerGroup.position.z
    };
  }, 1000);
}

function showSettings() {
  alert('⚔ SETTINGS ⚔\n\nVolume: 100%\nDifficulty: Normal\nCamera: Mouse Move\n\nPress ESC to return');
}

function pauseGame() {
  gamePaused = true;
  pauseOverlay.style.display = 'flex';
  if (timeInterval) clearInterval(timeInterval);
}

function resumeGame() {
  gamePaused = false;
  pauseOverlay.style.display = 'none';
  timeInterval = setInterval(() => {
    playTime++;
    const minutes = Math.floor(playTime / 60);
    const seconds = playTime % 60;
    if (menuTime) {
      menuTime.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    savedGame.playTime = playTime;
    savedGame.souls = player.souls;
    savedGame.enemiesSlain = enemiesSlain;
    savedGame.position = {
      x: playerGroup.position.x,
      y: playerGroup.position.y,
      z: playerGroup.position.z
    };
  }, 1000);
}

function restartGame() {
  playerGroup.position.set(2, 0, 2);
  player.hp = player.maxHp;
  player.stamina = player.maxStamina;
  player.souls = 0;
  enemiesSlain = 0;
  playTime = 0;

  document.getElementById('soulCount').innerText = '0';
  if (menuSouls) menuSouls.innerText = '0';
  if (menuEnemies) menuEnemies.innerText = '0';
  if (menuTime) menuTime.innerText = '00:00';

  enemies.forEach(enemy => scene.remove(enemy));
  enemies.length = 0;
  const basePath = getBasePath();
  const loader = new THREE.GLTFLoader();
  for (let i = 0; i < 3; i++) {
    loadSingleSkeleton(loader, i, false, basePath + 'Enemys/Skeleton.glb');
  }

  gamePaused = false;
  pauseOverlay.style.display = 'none';
}

function backToMenu() {
  gameStarted = false;
  gamePaused = false;
  pauseOverlay.style.display = 'none';
  menuOverlay.style.display = 'flex';
  ui.style.display = 'none';
  souls.style.display = 'none';
  cameraHint.style.display = 'none';
  bonfireHint.style.display = 'none';
  if (timeInterval) clearInterval(timeInterval);
}

// ===== FUNÇÃO PRINCIPAL DE CARREGAMENTO =====
function loadHighQualityModel() {
  loadingOverlay.style.display = 'flex';
  loadingMessage.style.display = 'block';
  loadingError.style.display = 'none';
  retryBtn.style.display = 'none';
  useFallbackBtn.style.display = 'none';

  loadingMessage.innerHTML = 'LOADING KNIGHT...';

  // Detecta o caminho base correto
  const basePath = getBasePath();
  const knightPath = basePath + 'knight/';
  
  console.log('Base path:', basePath);
  console.log('Knight path:', knightPath);

  const timeout = setTimeout(() => {
    if (!player) {
      console.log('Timeout loading knight - usando fallback');
      createFallbackPlayer();
      loadingMessage.innerHTML = 'LOADING COMPLETE (FALLBACK)';
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
        menuOverlay.style.display = 'flex';
      }, 1000);
    }
  }, 10000);

  // Carrega fogueira e inimigos com o caminho correto
  loadCampFire(basePath);
  loadSkeletonEnemies(basePath);

  // Tenta carregar o knight
  const objLoader = new THREE.OBJLoader();
  objLoader.setPath(knightPath);

  objLoader.load('knight.obj',
    (object) => {
      clearTimeout(timeout);
      console.log('Knight loaded successfully!');
      console.log('Knight object:', object);

      tryApplyTextures(object, knightPath);
      processLoadedModel(object);
      
      loadingMessage.innerHTML = 'LOADING COMPLETE!';
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
        menuOverlay.style.display = 'flex';
      }, 500);
    },
    (xhr) => {
      const percent = Math.round(xhr.loaded / xhr.total * 100);
      loadingMessage.innerHTML = `LOADING KNIGHT... ${percent}%`;
    },
    (error) => {
      clearTimeout(timeout);
      console.error('Erro ao carregar knight:', error);
      console.error('URL tentada:', knightPath + 'knight.obj');
      
      loadingMessage.innerHTML = 'KNIGHT FAILED - USING FALLBACK';
      createFallbackPlayer();
      
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
        menuOverlay.style.display = 'flex';
      }, 1500);
    }
  );

  function tryApplyTextures(object, knightPath) {
    const textureLoader = new THREE.TextureLoader();

    // Primeiro, garante que todas as partes têm uma cor base visível
    object.traverse((child) => {
      if (child.isMesh) {
        if (!child.material) {
          child.material = new THREE.MeshStandardMaterial({ color: 0x888888 });
        } else if (Array.isArray(child.material)) {
          child.material.forEach(mat => {
            if (!mat.color) mat.color = new THREE.Color(0x888888);
          });
        } else {
          if (!child.material.color) child.material.color = new THREE.Color(0x888888);
        }
      }
    });

    // Tenta armor.jpg
    textureLoader.load(knightPath + 'armor.jpg', 
      (texture) => {
        console.log('Armor texture loaded from:', knightPath + 'armor.jpg');
        applyTextureToModel(object, texture);
      }, 
      undefined, 
      (err) => {
        console.log('Armor texture not found at:', knightPath + 'armor.jpg');
      }
    );

    // Tenta gen.face.jpg
    textureLoader.load(knightPath + 'gen.face.jpg', 
      (texture) => {
        console.log('Face texture loaded from:', knightPath + 'gen.face.jpg');
        applyTextureToFace(object, texture);
      },
      undefined,
      (err) => {
        console.log('Face texture not found at:', knightPath + 'gen.face.jpg');
      }
    );
  }

  function applyTextureToModel(object, texture) {
    object.traverse((child) => {
      if (child.isMesh) {
        if (!child.material) {
          child.material = new THREE.MeshStandardMaterial({ map: texture });
        } else if (Array.isArray(child.material)) {
          child.material.forEach(mat => { 
            mat.map = texture; 
            mat.needsUpdate = true; 
          });
        } else {
          child.material.map = texture;
          child.material.needsUpdate = true;
        }
      }
    });
  }

  function applyTextureToFace(object, texture) {
    object.traverse((child) => {
      if (child.isMesh) {
        const nomeLower = child.name.toLowerCase();
        if (nomeLower.includes('head') || nomeLower.includes('face')) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => { 
              mat.map = texture; 
              mat.needsUpdate = true; 
            });
          } else {
            child.material.map = texture;
            child.material.needsUpdate = true;
          }
        }
      }
    });
  }

  function processLoadedModel(object) {
    console.log('Processando modelo...');
    
    // Calcula escala baseada na altura
    const box = new THREE.Box3().setFromObject(object);
    const originalHeight = box.max.y - box.min.y;
    const targetHeight = 2.0;
    const scale = targetHeight / originalHeight;
    
    console.log('Altura original:', originalHeight);
    console.log('Scale aplicado:', scale);
    
    // Aplica escala
    object.scale.set(scale, scale, scale);
    
    // Recalcula box após escala
    const scaledBox = new THREE.Box3().setFromObject(object);
    console.log('Nova altura:', scaledBox.max.y - scaledBox.min.y);
    
    // Rotação
    object.rotation.y = Math.PI;
    
    // Centraliza e coloca no chão
    object.position.y = -scaledBox.min.y;
    object.position.x = 0;
    object.position.z = 0;
    
    // Ajuste da espada
    const nomesEspada = ['sword', 'espada', 'weapon', 'blade'];
    object.traverse((child) => {
      if (child.isMesh) {
        const nomeLower = child.name.toLowerCase();
        if (nomesEspada.some(nome => nomeLower.includes(nome))) {
          console.log('Espada encontrada:', child.name);
          child.position.set(0.5, -0.5, 0.1);
          child.rotation.set(0, 0, 0);
        }
      }
    });
    
    // Configura sombras e materiais
    object.traverse((child) => {
      if(child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        
        // Garante que o material tem cor visível
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => {
              if (!mat.color || mat.color.getHex() === 0) {
                mat.color.setHex(0x888888);
              }
              mat.needsUpdate = true;
            });
          } else {
            if (!child.material.color || child.material.color.getHex() === 0) {
              child.material.color.setHex(0x888888);
            }
            child.material.needsUpdate = true;
          }
        }
      }
    });

    // Remove qualquer modelo anterior
    while(playerGroup.children.length > 0) {
      playerGroup.remove(playerGroup.children[0]);
    }
    
    // Adiciona o novo modelo
    playerGroup.add(object);
    
    // Configura propriedades do player
    playerGroup.hp = 5;
    playerGroup.maxHp = 5;
    playerGroup.stamina = 100;
    playerGroup.maxStamina = 100;
    playerGroup.velY = 0;
    playerGroup.onGround = true;
    playerGroup.souls = 0;
    playerGroup.invulnerable = false;
    playerGroup.isRolling = false;
    playerGroup.rollCooldown = 0;
    playerGroup.rollVelocity = new THREE.Vector3(0, 0, 0);

    player = playerGroup;
    
    // Posição inicial VISÍVEL
    playerGroup.position.set(0, 0, 5);
    
    scene.add(playerGroup);
    
    console.log('Modelo processado e adicionado à cena');
    console.log('PlayerGroup position:', playerGroup.position);
    console.log('PlayerGroup children:', playerGroup.children.length);
  }
}

// ===== CAMPFIRE =====
function loadCampFire(basePath) {
  const objLoader = new THREE.OBJLoader();
  const campfirePath = basePath + 'CampFire/';
  objLoader.setPath(campfirePath);

  objLoader.load('Campfire.obj', (object) => {
    processCampFire(object);
  }, undefined, () => {
    objLoader.load('Campfire_clean.OBJ', (object) => {
      processCampFire(object);
    }, undefined, () => {
      createFallbackBonfire();
    });
  });

  function processCampFire(object) {
    object.scale.set(0.025, 0.025, 0.025);
    object.position.set(0, 0, 0);

    object.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        if (!child.material) {
          child.material = new THREE.MeshStandardMaterial({ color: 0x886644 });
        }
      }
    });

    addFireParticles(object);

    if (bonfireModel) scene.remove(bonfireModel);
    bonfireModel = object;
    scene.add(object);
  }

  function addFireParticles(campfire) {
    const fireParticles = [];
    for(let i = 0; i < 15; i++) {
      const size = 0.1 + Math.random() * 0.15;
      const particle = new THREE.Mesh(
        new THREE.SphereGeometry(size, 4),
        new THREE.MeshStandardMaterial({ 
          color: 0xff6600, 
          emissive: 0x442200,
          transparent: true,
          opacity: 0.8
        })
      );
      particle.userData = {
        speed: 0.01 + Math.random() * 0.03,
        offset: Math.random() * Math.PI * 2,
        height: 0.4 + Math.random() * 0.8,
        startY: 0.2 + Math.random() * 0.3,
        phase: Math.random() * Math.PI * 2
      };
      particle.position.set(
        (Math.random() - 0.5) * 0.5,
        particle.userData.startY,
        (Math.random() - 0.5) * 0.5
      );
      particle.castShadow = true;
      campfire.add(particle);
      fireParticles.push(particle);
    }
    campfire.userData.fireParticles = fireParticles;
  }

  function createFallbackBonfire() {
    const bonfire = new THREE.Group();

    const base = new THREE.Mesh(
      new THREE.CylinderGeometry(0.8, 1, 0.3, 8),
      new THREE.MeshStandardMaterial({ color: 0x886644 })
    );
    base.position.y = 0.15;
    base.castShadow = true;
    base.receiveShadow = true;
    bonfire.add(base);

    for(let i = 0; i < 5; i++) {
      const log = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 0.8),
        new THREE.MeshStandardMaterial({ color: 0xaa8866 })
      );
      log.rotation.z = (Math.random() - 0.5) * 0.5;
      log.rotation.x = (Math.random() - 0.5) * 0.5;
      log.position.set(
        (Math.random() - 0.5) * 0.3,
        0.4,
        (Math.random() - 0.5) * 0.3
      );
      log.castShadow = true;
      log.receiveShadow = true;
      bonfire.add(log);
    }

    const fireParticles = [];
    for(let i = 0; i < 15; i++) {
      const size = 0.1 + Math.random() * 0.15;
      const particle = new THREE.Mesh(
        new THREE.SphereGeometry(size, 4),
        new THREE.MeshStandardMaterial({ 
          color: Math.random() > 0.3 ? 0xff6600 : 0xffaa00,
          emissive: 0x442200,
          transparent: true,
          opacity: 0.8
        })
      );
      particle.userData = {
        speed: 0.01 + Math.random() * 0.03,
        offset: Math.random() * Math.PI * 2,
        height: 0.4 + Math.random() * 0.8,
        startY: 0.2 + Math.random() * 0.3,
        phase: Math.random() * Math.PI * 2
      };
      particle.position.set(
        (Math.random() - 0.5) * 0.5,
        particle.userData.startY,
        (Math.random() - 0.5) * 0.5
      );
      particle.castShadow = true;
      bonfire.add(particle);
      fireParticles.push(particle);
    }
    bonfire.userData.fireParticles = fireParticles;

    bonfire.position.set(0, 0, 0);
    
    if (bonfireModel) scene.remove(bonfireModel);
    bonfireModel = bonfire;
    scene.add(bonfire);
  }
}

// ===== ENEMIES =====
const enemies = [];
const ENEMY_COLLISION_RADIUS = 1.2;

function loadSkeletonEnemies(basePath) {
  const loader = new THREE.GLTFLoader();
  const enemyPath = basePath + 'Enemys/Skeleton.glb';
  
  for (let i = 0; i < 3; i++) {
    loadSingleSkeleton(loader, i, true, enemyPath);
  }
}

function loadSingleSkeleton(loader, index, isInitialLoad = false, enemyPath) {
  const angle = (index / 3) * Math.PI * 2;
  const radius = 8;

  loader.load(
    enemyPath,
    (gltf) => {
      const skeleton = gltf.scene;

      skeleton.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
        }
      });

      skeleton.scale.set(0.4, 0.4, 0.4);
      skeleton.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);

      skeleton.userData = {
        hp: 3,
        maxHp: 3,
        cooldown: 0,
        isAlive: true
      };

      createHealthBar(skeleton);

      const soul = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 6),
        new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 })
      );
      soul.position.y = 2.0;
      soul.visible = false;
      soul.userData.isSoul = true;
      skeleton.add(soul);
      skeleton.userData.soulMesh = soul;

      if (gltf.animations && gltf.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(skeleton);
        const action = mixer.clipAction(gltf.animations[0]);
        action.play();
        skeletonMixers.push(mixer);
      }

      scene.add(skeleton);
      enemies.push(skeleton);

      console.log('Skeleton loaded');
    },
    undefined,
    (error) => {
      console.error('Erro ao carregar skeleton:', error);
      createFallbackEnemy(index, isInitialLoad);
    }
  );
}

function createFallbackEnemy(index, isInitialLoad = false) {
  const angle = (index / 3) * Math.PI * 2;
  const radius = 8;

  const e = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshStandardMaterial({ color: 0x880000 })
  );
  e.position.set(Math.cos(angle) * radius, 0.5, Math.sin(angle) * radius);
  e.userData = { hp: 3, maxHp: 3, cooldown: 0, isAlive: true };
  e.castShadow = true;
  e.receiveShadow = true;

  createHealthBar(e);

  const soul = new THREE.Mesh(
    new THREE.SphereGeometry(0.25, 6),
    new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 })
  );
  soul.position.y = 1.2;
  soul.visible = false;
  soul.userData.isSoul = true;
  e.add(soul);
  e.userData.soulMesh = soul;

  scene.add(e);
  enemies.push(e);
}

function createHealthBar(enemy) {
  const canvas = document.createElement('canvas');
  canvas.width = 50;
  canvas.height = 8;
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = '#330000';
  ctx.fillRect(0, 0, 50, 8);
  ctx.strokeStyle = '#000000';
  ctx.strokeRect(0, 0, 50, 8);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture });
  const sprite = new THREE.Sprite(material);
  sprite.position.y = 5.7;
  sprite.scale.set(1, 0.2, 1);
  enemy.add(sprite);
  enemy.userData.healthBar = { canvas, ctx, sprite };
  updateHealthBar(enemy);
}

function updateHealthBar(enemy) {
  if(!enemy.userData.healthBar) return;
  const ctx = enemy.userData.healthBar.ctx;
  const canvas = enemy.userData.healthBar.canvas;

  ctx.clearRect(0, 0, 50, 8);
  ctx.fillStyle = '#330000';
  ctx.fillRect(0, 0, 50, 8);

  const percent = enemy.userData.hp / enemy.userData.maxHp;
  if(percent > 0.6) ctx.fillStyle = '#00ff00';
  else if(percent > 0.3) ctx.fillStyle = '#ffff00';
  else ctx.fillStyle = '#ff0000';

  ctx.fillRect(1, 1, 48 * percent, 6);
  ctx.strokeStyle = '#000000';
  ctx.strokeRect(0, 0, 50, 8);

  enemy.userData.healthBar.sprite.material.map.needsUpdate = true;
}

// ===== FALLBACK PLAYER =====
function createFallbackPlayer() {
  const group = new THREE.Group();

  const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x6666ff });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.75;
  body.castShadow = true;
  body.receiveShadow = true;
  group.add(body);

  const headGeo = new THREE.SphereGeometry(0.25, 8);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.5;
  head.castShadow = true;
  head.receiveShadow = true;
  group.add(head);

  const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8);
  const armMat = new THREE.MeshStandardMaterial({ color: 0x6666ff });

  const leftArm = new THREE.Mesh(armGeo, armMat);
  leftArm.position.set(-0.4, 1.0, 0);
  leftArm.rotation.z = 0.2;
  leftArm.castShadow = true;
  leftArm.receiveShadow = true;
  group.add(leftArm);

  const rightArm = new THREE.Mesh(armGeo, armMat);
  rightArm.position.set(0.4, 1.0, 0);
  rightArm.rotation.z = -0.2;
  rightArm.castShadow = true;
  rightArm.receiveShadow = true;
  group.add(rightArm);

  const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8);
  const legMat = new THREE.MeshStandardMaterial({ color: 0x4444aa });

  const leftLeg = new THREE.Mesh(legGeo, legMat);
  leftLeg.position.set(-0.15, 0.4, 0);
  leftLeg.castShadow = true;
  leftLeg.receiveShadow = true;
  group.add(leftLeg);

  const rightLeg = new THREE.Mesh(legGeo, legMat);
  rightLeg.position.set(0.15, 0.4, 0);
  rightLeg.castShadow = true;
  rightLeg.receiveShadow = true;
  group.add(rightLeg);

  group.hp = 5;
  group.maxHp = 5;
  group.stamina = 100;
  group.maxStamina = 100;
  group.velY = 0;
  group.onGround = true;
  group.souls = 0;
  group.invulnerable = false;
  group.isRolling = false;
  group.rollCooldown = 0;
  group.rollVelocity = new THREE.Vector3(0, 0, 0);

  playerGroup.add(group);
  player = group;
  playerGroup.position.set(0, 1, 5);
  scene.add(playerGroup);
  
  console.log('Fallback player created');
}

// ===== SCENE =====
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x111122, 6, 30);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 100);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Luzes
const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
scene.add(ambientLight);

scene.add(new THREE.HemisphereLight(0x446688, 0x222222, 1));

const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
sun.position.set(5, 10, 5);
sun.castShadow = true;
sun.shadow.mapSize.width = 1024;
sun.shadow.mapSize.height = 1024;
scene.add(sun);

const fillLight = new THREE.PointLight(0x446688, 0.5);
fillLight.position.set(2, 5, 5);
scene.add(fillLight);

const backupLight = new THREE.DirectionalLight(0xffffff, 1);
backupLight.position.set(1, 1, 1);
scene.add(backupLight);

const fireLight = new THREE.PointLight(0xff6600, 0.8, 8);
fireLight.position.set(0, 1, 0);
scene.add(fireLight);

// Chão
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(60,60),
  new THREE.MeshStandardMaterial({color:0x1a1a1a})
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Paredes invisíveis
const wallMaterial = new THREE.MeshBasicMaterial({ visible: false });
const wallHeight = 5;
const wallThickness = 1;

const walls = [
  new THREE.Mesh(new THREE.BoxGeometry(60, wallHeight, wallThickness), wallMaterial),
  new THREE.Mesh(new THREE.BoxGeometry(60, wallHeight, wallThickness), wallMaterial),
  new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, 60), wallMaterial),
  new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, 60), wallMaterial)
];

walls[0].position.set(0, wallHeight/2, -30);
walls[1].position.set(0, wallHeight/2, 30);
walls[2].position.set(-30, wallHeight/2, 0);
walls[3].position.set(30, wallHeight/2, 0);

walls.forEach(wall => scene.add(wall));

// Estado do jogo
const keys = {};
let lockOn = false;
let targetEnemy = null;
let nearBonfire = false;

let rollCooldownTimer = 0;
const ROLL_COOLDOWN = 180;

function checkWallCollision(position) {
  const margin = 1.5;
  return (
    Math.abs(position.x) > MAP_LIMIT - margin ||
    Math.abs(position.z) > MAP_LIMIT - margin
  );
}

function performRoll() {
  if(!player) return;
  if (rollCooldownTimer > 0) return;

  player.stamina -= 30;
  player.isRolling = true;
  player.invulnerable = true;
  player.rollCooldown = 45;
  rollCooldownTimer = ROLL_COOLDOWN;

  document.getElementById('rollIndicator').style.display = 'block';

  let moveX = 0, moveZ = 0;
  if(keys["a"]) moveX -= 1;
  if(keys["d"]) moveX += 1;
  if(keys["w"]) moveZ -= 1;
  if(keys["s"]) moveZ += 1;

  if(moveX === 0 && moveZ === 0) moveZ = 1;

  const length = Math.sqrt(moveX*moveX + moveZ*moveZ);
  moveX /= length;
  moveZ /= length;

  const forward = new THREE.Vector3(Math.sin(cameraAngle), 0, Math.cos(cameraAngle));
  const right = new THREE.Vector3(Math.sin(cameraAngle + Math.PI/2), 0, Math.cos(cameraAngle + Math.PI/2));

  player.rollVelocity.x = (forward.x * moveZ + right.x * moveX) * 0.8;
  player.rollVelocity.z = (forward.z * moveZ + right.z * moveX) * 0.8;

  setTimeout(() => {
    if(player) {
      player.isRolling = false;
      player.invulnerable = false;
      player.rollVelocity.set(0, 0, 0);
      document.getElementById('rollIndicator').style.display = 'none';
    }
  }, 200);
}

function collectSouls() {
  if(!player) return;
  enemies.forEach(enemy => {
    if(!enemy.userData.isAlive && enemy.userData.soulMesh && enemy.userData.soulMesh.visible) {
      const d = playerGroup.position.distanceTo(enemy.position);
      if(d < 2) {
        player.souls++;
        document.getElementById('soulCount').innerText = player.souls;
        if (menuSouls) menuSouls.innerText = player.souls;
        enemy.userData.soulMesh.visible = false;
        savedGame.souls = player.souls;
      }
    }
  });
}

let lastRestTime = 0;
function restAtBonfire() {
  if(!player) return;
  const now = Date.now();
  if(now - lastRestTime < 3000) return;

  player.hp = player.maxHp;
  player.stamina = player.maxStamina;
  lastRestTime = now;

  savedGame.position = {
    x: playerGroup.position.x,
    y: playerGroup.position.y,
    z: playerGroup.position.z
  };
  savedGame.souls = player.souls;
  savedGame.enemiesSlain = enemiesSlain;

  if (bonfireModel) {
    bonfireModel.traverse((child) => {
      if (child.isMesh && child.material) {
        child.material.emissive?.setHex(0x442200);
        setTimeout(() => {
          if (child.material) child.material.emissive?.setHex(0x000000);
        }, 500);
      }
    });
  }

  enemies.forEach(enemy => { if(!enemy.userData.isAlive) scene.remove(enemy); });
  for (let i = enemies.length - 1; i >= 0; i--) {
    if (!enemies[i].userData.isAlive) enemies.splice(i, 1);
  }

  const basePath = getBasePath();
  const loader = new THREE.GLTFLoader();
  for(let i = enemies.length; i < 3; i++) {
    loadSingleSkeleton(loader, i, false, basePath + 'Enemys/Skeleton.glb');
  }
}

function applyEnemyCollision() {
  for (let i = 0; i < enemies.length; i++) {
    const enemyA = enemies[i];
    if (!enemyA.userData.isAlive) continue;
    for (let j = i + 1; j < enemies.length; j++) {
      const enemyB = enemies[j];
      if (!enemyB.userData.isAlive) continue;

      const dx = enemyA.position.x - enemyB.position.x;
      const dz = enemyA.position.z - enemyB.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);

      if (dist < ENEMY_COLLISION_RADIUS) {
        const angle = Math.atan2(dz, dx);
        const overlap = ENEMY_COLLISION_RADIUS - dist;
        const moveX = Math.cos(angle) * overlap * 0.5;
        const moveZ = Math.sin(angle) * overlap * 0.5;

        enemyA.position.x += moveX;
        enemyA.position.z += moveZ;
        enemyB.position.x -= moveX;
        enemyB.position.z -= moveZ;
      }
    }
  }
}

function rotatePlayerModel(direction) {
  if (!playerGroup.children[0]) return;
  
  const model = playerGroup.children[0];
  
  if (model.children && model.children.length > 0) {
    let targetRot = Math.atan2(direction.x, direction.z);
    let diff = targetRot - model.rotation.y;
    while(diff > Math.PI) diff -= Math.PI * 2;
    while(diff < -Math.PI) diff += Math.PI * 2;
    model.rotation.y += diff * 0.2;
  } 
  else if (model.isMesh) {
    let targetRot = Math.atan2(direction.x, direction.z);
    let diff = targetRot - model.rotation.y;
    while(diff > Math.PI) diff -= Math.PI * 2;
    while(diff < -Math.PI) diff += Math.PI * 2;
    model.rotation.y += diff * 0.2;
  }
}

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  skeletonMixers.forEach(mixer => mixer.update(delta));

  if(!gameStarted || gamePaused || !player) {
    renderer.render(scene, camera);
    return;
  }

  if (rollCooldownTimer > 0) {
    rollCooldownTimer--;
  }

  cameraAngle += (targetCameraAngle - cameraAngle) * cameraSmoothness;

  applyEnemyCollision();

  if (bonfireModel && bonfireModel.userData.fireParticles) {
    bonfireModel.userData.fireParticles.forEach((particle) => {
      const time = Date.now() * particle.userData.speed + particle.userData.offset;
      particle.position.y = particle.userData.startY + Math.sin(time) * particle.userData.height;
      const scale = 0.8 + Math.sin(time * 3) * 0.3;
      particle.scale.set(scale, scale, scale);
      if (particle.material) {
        particle.material.opacity = 0.5 + Math.sin(time * 2) * 0.3;
      }
    });
    fireLight.intensity = 0.6 + Math.sin(Date.now() * 0.01) * 0.2;
  }

  let moveX = 0, moveZ = 0;
  const speed = 0.06;

  if(!player.isRolling) {
    if(keys["w"]) moveZ -= 1;
    if(keys["s"]) moveZ += 1;
    if(keys["a"]) moveX -= 1;
    if(keys["d"]) moveX += 1;
  }

  if(player.isRolling) {
    playerGroup.position.x += player.rollVelocity.x;
    playerGroup.position.z += player.rollVelocity.z;
    player.rollVelocity.x *= 0.9;
    player.rollVelocity.z *= 0.9;

    if (checkWallCollision(playerGroup.position)) {
      playerGroup.position.x -= player.rollVelocity.x;
      playerGroup.position.z -= player.rollVelocity.z;
    }
  } else if(moveX !== 0 || moveZ !== 0) {
    const length = Math.sqrt(moveX*moveX + moveZ*moveZ);
    moveX /= length;
    moveZ /= length;

    if(lockOn && targetEnemy && targetEnemy.userData.isAlive) {
      const toEnemy = new THREE.Vector3().subVectors(targetEnemy.position, playerGroup.position).normalize();
      const right = new THREE.Vector3().crossVectors(toEnemy, new THREE.Vector3(0, 1, 0)).normalize();

      let newX = playerGroup.position.x;
      let newZ = playerGroup.position.z;

      if(moveZ !== 0) {
        newX += toEnemy.x * -moveZ * speed;
        newZ += toEnemy.z * -moveZ * speed;
      }
      if(moveX !== 0) {
        newX += right.x * moveX * speed;
        newZ += right.z * moveX * speed;
      }

      const testPos = new THREE.Vector3(newX, playerGroup.position.y, newZ);
      if (!checkWallCollision(testPos)) {
        playerGroup.position.copy(testPos);
      }
    } else {
      const forward = new THREE.Vector3(Math.sin(cameraAngle), 0, Math.cos(cameraAngle));
      const right = new THREE.Vector3(Math.sin(cameraAngle + Math.PI/2), 0, Math.cos(cameraAngle + Math.PI/2));

      let newX = playerGroup.position.x + (forward.x * moveZ + right.x * moveX) * speed;
      let newZ = playerGroup.position.z + (forward.z * moveZ + right.z * moveX) * speed;

      const testPos = new THREE.Vector3(newX, playerGroup.position.y, newZ);
      if (!checkWallCollision(testPos)) {
        playerGroup.position.copy(testPos);
      }
    }

    if(!lockOn && !player.isRolling && (moveX !== 0 || moveZ !== 0)) {
      const moveDir = Math.atan2(moveX, moveZ) + cameraAngle;
      rotatePlayerModel(new THREE.Vector3(Math.sin(moveDir), 0, Math.cos(moveDir)));
    }
  }

  if(keys[" "] && player.onGround && player.stamina >= 15 && !player.isRolling) {
    player.velY = 0.2;
    player.stamina -= 15;
    player.onGround = false;
  }

  player.velY -= 0.01;
  playerGroup.position.y += player.velY;
  if(playerGroup.position.y <= 0) {
    playerGroup.position.y = 0;
    player.velY = 0;
    player.onGround = true;
  }

  if(!player.isRolling) player.stamina = Math.min(player.maxStamina, player.stamina + 0.4);
  if(player.rollCooldown > 0) player.rollCooldown--;

  enemies.forEach(enemy => {
    if(enemy.userData.isAlive) {
      const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position);
      const dist = dir.length();
      dir.normalize();

      let newX = enemy.position.x + dir.x * 0.02;
      let newZ = enemy.position.z + dir.z * 0.02;

      const testPos = new THREE.Vector3(newX, enemy.position.y, newZ);
      if (!checkWallCollision(testPos)) {
        enemy.position.x = newX;
        enemy.position.z = newZ;
      }

      enemy.rotation.y = Math.atan2(dir.x, dir.z);

      if(dist < 1.5 && enemy.userData.cooldown <= 0) {
        if(!player.invulnerable) player.hp--;
        enemy.userData.cooldown = 60;

        if(player.hp <= 0) {
          playerGroup.position.set(2, 0, 2);
          player.hp = player.maxHp;
          player.stamina = player.maxStamina;
          player.souls = 0;
          document.getElementById('soulCount').innerText = '0';
          if (menuSouls) menuSouls.innerText = '0';
        }
      } else {
        enemy.userData.cooldown--;
      }
    } else if (enemy.userData.soulMesh) {
      enemy.userData.soulMesh.position.y = 2.0 + Math.sin(Date.now() * 0.005) * 0.2;
      enemy.userData.soulMesh.rotation.y += 0.02;
    }
  });

  collectSouls();

  if (bonfireModel) {
    const distToBonfire = playerGroup.position.distanceTo(bonfireModel.position);
    nearBonfire = distToBonfire < 3;
    bonfireHint.style.display = nearBonfire ? 'block' : 'none';
  }

  document.getElementById('hp').innerText = player.hp;
  document.getElementById('st').innerText = Math.floor(player.stamina);

  if(lockOn && targetEnemy && targetEnemy.userData.isAlive) {
    const playerPos = playerGroup.position.clone();
    const enemyPos = targetEnemy.position.clone();
    const dirToEnemy = new THREE.Vector3().subVectors(enemyPos, playerPos).normalize();
    const camOffset = dirToEnemy.clone().multiplyScalar(-cameraDistance);
    camOffset.y += cameraHeight * 0.5;
    camera.position.copy(playerPos.clone().add(camOffset));
    camera.lookAt(enemyPos);
  } else {
    const camX = Math.sin(cameraAngle) * Math.cos(cameraVerticalAngle) * cameraDistance;
    const camY = Math.sin(cameraVerticalAngle) * cameraDistance + cameraHeight;
    const camZ = Math.cos(cameraAngle) * Math.cos(cameraVerticalAngle) * cameraDistance;

    camera.position.set(
      playerGroup.position.x + camX,
      playerGroup.position.y + camY,
      playerGroup.position.z + camZ
    );

    camera.lookAt(playerGroup.position.clone().add(new THREE.Vector3(0, 1.2, 0)));
  }

  renderer.render(scene, camera);
}

// ===== INICIAR =====
loadHighQualityModel();
animate();
</script>
</body>
</html>
